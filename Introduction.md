## 数据结构  
### 逻辑结构  
- 集合结构：数据结构中的元素之间除了“同属一个集合” 的相互关系外，别无其他关系； 
- 线性结构：数据结构中的元素存在一对一的相互关系； 
-. 树形结构：数据结构中的元素存在一对多的相互关系； 
- 图形结构：数据结构中的元素存在多对多的相互关系。  

![逻辑结构](https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/crop%3D0%2C1%2C733%2C484%3Bc0%3Dbaike92%2C5%2C5%2C92%2C30/sign=3b23b6787e094b36cfdd41ad9efc50e8/a6efce1b9d16fdfaa5df8e49bc8f8c5495ee7be1.jpg)

### 物理结构  
- 顺序存储：把逻辑上相邻的节点存储在物理位置上相邻的存储单元中，结点之间的逻辑关系由存储单元的邻接关系来体现。  
- 链式存储：在计算机中用一组任意的存储单元存储线性表的数据元素(这组存储单元可以是连续的,也可以是不连续的)。 
- 索引存储: 除建立存储结点信息外，还建立附加的索引表来标识结点的地址。 
- 散列存储：根据结点的关键字直接计算出该结点的存储地址。

----
## 算法 
### 特征 
- 有穷性： 一个算法必须保证执行有限步之后结束；
- 确切性： 算法的每一步骤必须有确切的定义；
- 输入：一个算法有0个或多个输入，以刻画运算对象的初始情况，所谓0个输入是指算法本身定除了初始条件；
- 输出：一个算法有一个或多个输出，以反映对输入数据加工后的结果。没有输出的算法是毫无意义的；
- 可行性： 算法原则上能够精确地运行，而且人们用笔和纸做有限次运算后即可完成。

### 设计要求 
- 正确性：算法的正确性是指算法至少具有输入，输出和加工处理无歧义，并且可以正确反映问题的需求，以及正确得到问题的答案。 
1. 算法程序没有语法错误。
2. 算法程序能够根据正确的输入的值得到满足要求的输出结果。 
3. 算法程序能够根据错误的输入的值得到满足规格说明的输出结果。 
4. 算法程序对于精心设计的，极其刁难的测试数据都能满足要求的输出结果。
- 可读性：算法设计的另一个目的是为了便于阅读，理解和沟通，如果写的代码只有你和上帝能看懂，那这个算法只能说明很失败，因为算法越难理解，就越难找到他的bug，对于调试和修改就更难了 
- 健壮性：当输入的数据不合法的时候，算法也能给出相关的处理，而不是产生异常或者莫名起码的错误。 
- 时间效率高和空间存储量低：在满足以上几点以后，我们还可以考虑对算法程序进一步优化，尽量满足时间效率高和空间存储量低的需求。

--- 
## 效率   
事后统计方法：这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低。  
但这种方法显然是有很大缺陷的：  
1. 必须依据算法事先编制好测试程序，通常需要花费大量时间和精力，完了发觉测试的是糟糕的算法，那不是功亏一篑？赔了娘子又折兵？ 
2. 不同测试环境差别不是一般的大！

事前分析估算方法：在计算机程序编写前，依据统计方法对算法进行估算。  
经过总结，我们发现一个高级语言编写的程序在计算机上运行时所消耗的时间取决于下列因素： 
1. 算法采用的策略，方案
2. 编译产生的代码质量 
3. 问题的输入规模
4. 机器执行指令的速度   

由此可见，抛开这些与计算机硬件、软件有关的因素，一个程序的运行时间依赖于算法的好坏和问题的输入规模。（所谓的问题输入规模是指输入量的多少）

### 高斯算法示例分析  
普通算法：  
```java
int i, sum = 0, n = 100;   // 执行1次
for( i=1; i <= n; i++ )    // 执行了n+1次
{
    sum = sum + i;          // 执行n次
}
```
高斯算法：  
```java
int sum = 0, n = 100;     // 执行1次
sum = (1+n)*n/2;          // 执行1次
```  
第一种算法执行了1+(n+1)+n=2n+2次。   
第二种算法，是1+1=2次   
如果我们把循环看做一个整体，忽略头尾判断的开销，那么这两个算法其实就是n和1的差距。    
**问题：**  循环判断在算法1里边执行了n+1次，看起来是个不小的数量，凭什么说忽略就能忽略？  

### 再来一个例子  
```java
int i, j, x=0, sum=0, n=100;
for( i=1; i <= n; i++ ) {
    for( j=1; j <= n; j++ ) {
        x++;
        sum = sum + x;
    }
}
```
这个例子中，循环条件i从1到100，每次都要让j循环100次，如果非常较真的研究总共精确执行次数，那是非常累的。   

另一方面，我们研究算法的复杂度，侧重的是研究算法随着输入规模扩大增长量的一个抽象，而不是精确地定位需要执行多少次，因为如果这样的话，我们就又得考虑回编译器优化等问题，然后，然后就永远也没有然后了！  

所以，对于这个例子的算法，我们可以果断判定需要执行100^2次。    

### 函数的渐进增长  
#### 测试一
假设两个算法的输入规模都是n，算法A要做2n+3次操作，你可以这么理解：先执行n次的循环，执行完成后再有一个n次的循环，最后有3次运算。
算法B要做3n+1次操作，理解同上，你觉得它们哪一个更快些呢？  

![测试一.png](http://upload-images.jianshu.io/upload_images/293077-a1cfc1e935408684.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)  

当n=1时，算法A1效率不如算法B1，当n=2时，两者效率相同；当n>2时，算法A1就开始优于算法B1了，随着n的继续增加，算法A1比算法B1逐步拉大差距。所以总体上算法A1比算法B1优秀。

**函数的渐近增长：** 给定两个函数f(n)和g(n)，如果存在一个整数N，使得对于所有的n>N，f(n)总是比g(n)大，那么，我们说f(n)的增长渐近快于g(n)。  
从刚才的对比中我们还发现，随着n的增大，后面的+3和+1其实是不影响最终的算法变化曲线的。


#### 测试二
第二个测试，算法C是4n+8，算法D是2n^2+1。  
![测试二](http://upload-images.jianshu.io/upload_images/293077-661793a1aea20301.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

我们观察发现，哪怕去掉与n相乘的常数，两者的结果还是没有改变，算法C2的次数随着n的增长，还是远小于算法D2。  
也就是说，与最高次项相乘的常数并不重要，也可以忽略。

#### 测试三
第三个测试，算法E是2n^2+3n+1，算法F是2n^3+3n+1。  
![测试三](http://upload-images.jianshu.io/upload_images/293077-d8c2bc5b90f6b02e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

我们通过观察又发现，最高次项的指数大的，函数随着n的增长，结果也会变得增长特别快。


#### 测试四 
![测试四](http://upload-images.jianshu.io/upload_images/293077-6def1ef22a6fbfcb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

这组数据我们看得很清楚，当n的值变得非常大的时候，3n+1已经没法和2n^2的结果相比较，最终几乎可以忽略不计。而算法G在跟算法I基本已经重合了。


#### 结论
于是我们可以得到这样一个结论，判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项（最高项）的阶数。  

注意，判断一个算法好不好，我们只通过少量的数据是不能做出准确判断的，很容易以偏概全。  

----

## 算法时间复杂度 
算法时间复杂度的定义：在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。  

一般情况下，随着输入规模n的增大，T(n)增长最慢的算法为最优算法。

### 大O表示法  
算法的时间复杂度，也就是算法的时间量度，记作：T(n)= O(f(n))。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的某个函数。

这样用大写O()来体现算法时间复杂度的记法，我们称之为大O记法。

### 推导大O表示法的方法 
1. 用常数1来取代运行时间中所有加法常数。
2. 修改后的运行次数函数中，只保留最高阶项
3. 如果最高阶项存在且不是1，则去除与这个项相乘的常数。 

### 常数阶 
```java
int sum = 0, n = 100;
printf("Hello World");
printf("Hello World");
printf("Hello World");
printf("Hello World");
printf("Hello World");
printf("Hello World");
sum = (1+n)*n/2;
```
你认为上面代码的时间复杂度用大O表示法应该是多少？  

O(8)？  
这是初学者常常犯的错误，总认为有多少条语句就有多少。 

**分析：** 
按照我们的概念“T(n)是关于问题规模n的函数”来说，那么几条输出语句跟问题规模n一点关系都没有。所以直接记作O(1)就可以了。 
另外，如果按照攻略来，那就更简单了，攻略第一条就说明了用常数1来取代运行时间中所有加法常数，所以直接记作O(1)就可以了。 

### 线性阶 
一般含有非嵌套循环涉即线性阶，线性阶就是随着问题规模n的扩大，对应计算次数呈直线增长。
```java
int i , n = 100, sum = 0;
for( i=0; i < n; i++ ) {
    sum = sum + i;
}

```  
上面这段代码，它的循环的时间复杂度为O(n)，因为循环体中的代码需要执行n次。

### 平方阶  
如果是嵌套循环呢？ 
```java
int i, j, n = 100;
for( i=0; i < n; i++ ) {
    for( j=0; j < n; j++ ) {
        printf("Hello World");
    }
}
```   
n等于100，也就是说外层循环每执行一次，内层循环就执行100次，那总共程序想要从这两个循环出来，需要执行100*100次，也就是n的平方。所以这段代码的时间复杂度为O(n^2)。  

那如果有三个这样的嵌套循环呢？
没错，那就是n^3啦。所以我们很容易总结得出，循环的时间复杂度等于循环体的复杂度乘以该循环运行的次数。

但如果是这样的循环呢？ 
```java
int i, j, n = 100;
for( i=0; i < n; i++ ) {
    for( j=i; j < n; j++ ) {
        printf("Hello World");
    }
}
``` 
这里需要注意，内层循环的次数是变动的了，不是每次都执行100次了。   

由于当i=0时，内循环执行了n次，当i=1时，内循环则执行n-1次……当i=n-1时，内循环执行1次，所以总的执行次数应该是：
n+(n-1)+(n-2)+…+1 = n(n+1)/2 
所以加上外层的循环次数一起，那么就是：n(n+1)/2 = n^2/2+n/2

用我们推导大O的攻略，第一条忽略，因为没有常数相加。第二条只保留最高项，所以n/2这项去掉。第三条，去除与最高项相乘的常数，最终得O(n^2)  

### 对数阶 
```java
int i = 1, n = 100;
while( i < n ) {
    i = i * 2;
}
``` 
由于每次i*2之后，就距离n更近一步，假设有x个2相乘后大于或等于n，则会退出循环。 
于是由2^x = n得到x = log(2)n，所以这个循环的时间复杂度为O(logn)。

### 更多 
程序的世界是复杂的，所以大O表示法也不仅仅刚才提到的几个，还有比如：O(2^n) 指数阶，O(n*log(n)) 线性对数阶等等。 

常用的时间复杂度所耗费的时间从小到大依次是：

O(1) < O(logn) < O(n) < O(nlogn) < O(n2) < O(n3) < O(2n) < O(n!) < O(n^n)  

### 最坏情况与平均情况 
我们查找一个有n个随机数字数组中的某个数字，最好的情况是第一个数字就是，那么算法的时间复杂度为O(1)，但也有可能这个数字就在最后一个位置，那么时间复杂度为O(n)。
 
最坏运行时间是一种保证。在应用中，这是一种最重要的需求，通常除非特别指定，我们提到的运行时间都是最坏情况的运行时间。
 

![总结](https://camo.githubusercontent.com/d48e451ee2a88ba7cb9d14efa4c669a07fd11ac0/68747470733a2f2f706963312e7a68696d672e636f6d2f76322d61313338376330646637356233626330666338313238356566643066656437305f622e6a7067)


## 空间复杂度 
我们在写代码时，完全可以用空间来换去时间。 
举个例子说，要判断某年是不是闰年，你可能会花一点心思来写一个算法，每给一个年份，就可以通过这个算法计算得到是否闰年的结果。  
另外一种方法是，事先建立一个有2050个元素的数组，然后把所有的年份按下标的数字对应，如果是闰年，则此数组元素的值是1，如果不是元素的值则为0。这样，所谓的判断某一年是否为闰年就变成了查找这个数组某一个元素的值的问题。  

第一种方法相比起第二种来说很明显非常节省空间，但每一次查询都需要经过一系列的计算才能知道是否为闰年。第二种方法虽然需要在内存里存储2050个元素的数组，但是每次查询只需要一次索引判断即可。

这就是通过一笔空间上的开销来换取计算时间开销的小技巧。到底哪一种方法好？其实还是要看你用在什么地方。  

算法的空间复杂度通过计算算法所需的存储空间实现，算法的空间复杂度的计算公式记作：S(n)=O(f(n))，其中，n为问题的规模，f(n)为语句关于n所占存储空间的函数。

当直接要让我们求“复杂度”时，通常指的是时间复杂度。
 



