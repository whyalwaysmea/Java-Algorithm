# 希尔排序  
希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序  

简单插入排序很循规蹈矩，不管数组分布是怎么样的，依然一步一步的对元素进行比较，移动，插入，比如[5,4,3,2,1,0]这种倒序序列，数组末端的0要回到首位置很是费劲，比较和移动元素均需n-1次。  
希尔排序在数组中采用跳跃式分组的策略，把记录按下标的一定增量分组，对每组使用直接插入排序算法排序，随后逐步缩小增量，继续按组进行插入排序操作，直至增量为1。

假设数组{25,46,21,4,65,3,0,91,23,8}  

1. 第一轮增量设置为5，所以将数组分为5组，分组情况：{25, 3}, {46, 0}, {21, 91}, {4, 23}, {65, 8}。然后分别进行插入排序，排序后的数组是：3,0,21,4,65,25,46,91,23,8  
2. 第二轮增量为2，所以分成2组，分组情况：{3, 21, 5, 46, 23}和{0, 4, 25, 91, 8}。然后分别进行插入排序，排序后的数组是: 3,0,21,4,23,8,46,25,65,91 
3. 第三轮增量为1，整个数组为1组，再进行插入排序，最后：{0,3,4,8,21,23,25,46,65,91} 


# 算法实现 
```java
public class ShellSort {
    /**
     * 希尔排序 针对有序序列在插入时采用交换法
     * @param arr
     */
    public static void sort(int []arr){
        //增量gap，并逐步缩小增量
        for(int gap=arr.length/2; gap>0; gap/=2){
            //从第gap个元素，逐个对其所在组进行直接插入排序操作
            for(int i=gap; i<arr.length; i++){
                int j = i;
                while(j-gap>=0 && arr[j]<arr[j-gap]){
                    //插入排序采用交换法
                    swap(arr,j,j-gap);
                    j-=gap;
                }
            }
        }
    }

    /**
     * 希尔排序 针对有序序列在插入时采用移动法。
     * @param arr
     */
    public static void sort1(int []arr){
        //增量gap，并逐步缩小增量
        for(int gap=arr.length/2;gap>0;gap/=2){
            //从第gap个元素，逐个对其所在组进行直接插入排序操作
            for(int i=gap;i<arr.length;i++){
                int j = i;
                int temp = arr[j];
                if(arr[j]<arr[j-gap]){
                    while(j-gap>=0 && temp<arr[j-gap]){
                        //移动法
                        arr[j] = arr[j-gap];
                        j-=gap;
                    }
                    arr[j] = temp;
                }
            }
        }
    }
   
    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp; 
    }
}
```


# 算法效率 
希尔排序的时间复杂度，与增量息息相关：我们上面选择的增量序列{n/2,(n/2)/2...1}(希尔增量)，其最坏时间复杂度依然为O(n2)，一些经过优化的增量序列如Hibbard经过复杂证明可使得最坏时间复杂度为O(n3/2)。  

空间复杂度 O(1)  

不稳定